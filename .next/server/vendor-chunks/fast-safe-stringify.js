"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fast-safe-stringify";
exports.ids = ["vendor-chunks/fast-safe-stringify"];
exports.modules = {

/***/ "(ssr)/./node_modules/fast-safe-stringify/index.js":
/*!***************************************************!*\
  !*** ./node_modules/fast-safe-stringify/index.js ***!
  \***************************************************/
/***/ ((module) => {

eval("\nmodule.exports = stringify;\nstringify.default = stringify;\nstringify.stable = deterministicStringify;\nstringify.stableStringify = deterministicStringify;\nvar LIMIT_REPLACE_NODE = \"[...]\";\nvar CIRCULAR_REPLACE_NODE = \"[Circular]\";\nvar arr = [];\nvar replacerStack = [];\nfunction defaultOptions() {\n    return {\n        depthLimit: Number.MAX_SAFE_INTEGER,\n        edgesLimit: Number.MAX_SAFE_INTEGER\n    };\n}\n// Regular stringify\nfunction stringify(obj, replacer, spacer, options) {\n    if (typeof options === \"undefined\") {\n        options = defaultOptions();\n    }\n    decirc(obj, \"\", 0, [], undefined, 0, options);\n    var res;\n    try {\n        if (replacerStack.length === 0) {\n            res = JSON.stringify(obj, replacer, spacer);\n        } else {\n            res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);\n        }\n    } catch (_) {\n        return JSON.stringify(\"[unable to serialize, circular reference is too complex to analyze]\");\n    } finally{\n        while(arr.length !== 0){\n            var part = arr.pop();\n            if (part.length === 4) {\n                Object.defineProperty(part[0], part[1], part[3]);\n            } else {\n                part[0][part[1]] = part[2];\n            }\n        }\n    }\n    return res;\n}\nfunction setReplace(replace, val, k, parent) {\n    var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);\n    if (propertyDescriptor.get !== undefined) {\n        if (propertyDescriptor.configurable) {\n            Object.defineProperty(parent, k, {\n                value: replace\n            });\n            arr.push([\n                parent,\n                k,\n                val,\n                propertyDescriptor\n            ]);\n        } else {\n            replacerStack.push([\n                val,\n                k,\n                replace\n            ]);\n        }\n    } else {\n        parent[k] = replace;\n        arr.push([\n            parent,\n            k,\n            val\n        ]);\n    }\n}\nfunction decirc(val, k, edgeIndex, stack, parent, depth, options) {\n    depth += 1;\n    var i;\n    if (typeof val === \"object\" && val !== null) {\n        for(i = 0; i < stack.length; i++){\n            if (stack[i] === val) {\n                setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n                return;\n            }\n        }\n        if (typeof options.depthLimit !== \"undefined\" && depth > options.depthLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        if (typeof options.edgesLimit !== \"undefined\" && edgeIndex + 1 > options.edgesLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        stack.push(val);\n        // Optimize for Arrays. Big arrays could kill the performance otherwise!\n        if (Array.isArray(val)) {\n            for(i = 0; i < val.length; i++){\n                decirc(val[i], i, i, stack, val, depth, options);\n            }\n        } else {\n            var keys = Object.keys(val);\n            for(i = 0; i < keys.length; i++){\n                var key = keys[i];\n                decirc(val[key], key, i, stack, val, depth, options);\n            }\n        }\n        stack.pop();\n    }\n}\n// Stable-stringify\nfunction compareFunction(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n}\nfunction deterministicStringify(obj, replacer, spacer, options) {\n    if (typeof options === \"undefined\") {\n        options = defaultOptions();\n    }\n    var tmp = deterministicDecirc(obj, \"\", 0, [], undefined, 0, options) || obj;\n    var res;\n    try {\n        if (replacerStack.length === 0) {\n            res = JSON.stringify(tmp, replacer, spacer);\n        } else {\n            res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);\n        }\n    } catch (_) {\n        return JSON.stringify(\"[unable to serialize, circular reference is too complex to analyze]\");\n    } finally{\n        // Ensure that we restore the object as it was.\n        while(arr.length !== 0){\n            var part = arr.pop();\n            if (part.length === 4) {\n                Object.defineProperty(part[0], part[1], part[3]);\n            } else {\n                part[0][part[1]] = part[2];\n            }\n        }\n    }\n    return res;\n}\nfunction deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {\n    depth += 1;\n    var i;\n    if (typeof val === \"object\" && val !== null) {\n        for(i = 0; i < stack.length; i++){\n            if (stack[i] === val) {\n                setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n                return;\n            }\n        }\n        try {\n            if (typeof val.toJSON === \"function\") {\n                return;\n            }\n        } catch (_) {\n            return;\n        }\n        if (typeof options.depthLimit !== \"undefined\" && depth > options.depthLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        if (typeof options.edgesLimit !== \"undefined\" && edgeIndex + 1 > options.edgesLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        stack.push(val);\n        // Optimize for Arrays. Big arrays could kill the performance otherwise!\n        if (Array.isArray(val)) {\n            for(i = 0; i < val.length; i++){\n                deterministicDecirc(val[i], i, i, stack, val, depth, options);\n            }\n        } else {\n            // Create a temporary object in the required way\n            var tmp = {};\n            var keys = Object.keys(val).sort(compareFunction);\n            for(i = 0; i < keys.length; i++){\n                var key = keys[i];\n                deterministicDecirc(val[key], key, i, stack, val, depth, options);\n                tmp[key] = val[key];\n            }\n            if (typeof parent !== \"undefined\") {\n                arr.push([\n                    parent,\n                    k,\n                    val\n                ]);\n                parent[k] = tmp;\n            } else {\n                return tmp;\n            }\n        }\n        stack.pop();\n    }\n}\n// wraps replacer function to handle values we couldn't replace\n// and mark them as replaced value\nfunction replaceGetterValues(replacer) {\n    replacer = typeof replacer !== \"undefined\" ? replacer : function(k, v) {\n        return v;\n    };\n    return function(key, val) {\n        if (replacerStack.length > 0) {\n            for(var i = 0; i < replacerStack.length; i++){\n                var part = replacerStack[i];\n                if (part[1] === key && part[0] === val) {\n                    val = part[2];\n                    replacerStack.splice(i, 1);\n                    break;\n                }\n            }\n        }\n        return replacer.call(this, key, val);\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFzdC1zYWZlLXN0cmluZ2lmeS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQUFBLE9BQU9DLE9BQU8sR0FBR0M7QUFDakJBLFVBQVVDLE9BQU8sR0FBR0Q7QUFDcEJBLFVBQVVFLE1BQU0sR0FBR0M7QUFDbkJILFVBQVVJLGVBQWUsR0FBR0Q7QUFFNUIsSUFBSUUscUJBQXFCO0FBQ3pCLElBQUlDLHdCQUF3QjtBQUU1QixJQUFJQyxNQUFNLEVBQUU7QUFDWixJQUFJQyxnQkFBZ0IsRUFBRTtBQUV0QixTQUFTQztJQUNQLE9BQU87UUFDTEMsWUFBWUMsT0FBT0MsZ0JBQWdCO1FBQ25DQyxZQUFZRixPQUFPQyxnQkFBZ0I7SUFDckM7QUFDRjtBQUVBLG9CQUFvQjtBQUNwQixTQUFTWixVQUFXYyxHQUFHLEVBQUVDLFFBQVEsRUFBRUMsTUFBTSxFQUFFQyxPQUFPO0lBQ2hELElBQUksT0FBT0EsWUFBWSxhQUFhO1FBQ2xDQSxVQUFVUjtJQUNaO0lBRUFTLE9BQU9KLEtBQUssSUFBSSxHQUFHLEVBQUUsRUFBRUssV0FBVyxHQUFHRjtJQUNyQyxJQUFJRztJQUNKLElBQUk7UUFDRixJQUFJWixjQUFjYSxNQUFNLEtBQUssR0FBRztZQUM5QkQsTUFBTUUsS0FBS3RCLFNBQVMsQ0FBQ2MsS0FBS0MsVUFBVUM7UUFDdEMsT0FBTztZQUNMSSxNQUFNRSxLQUFLdEIsU0FBUyxDQUFDYyxLQUFLUyxvQkFBb0JSLFdBQVdDO1FBQzNEO0lBQ0YsRUFBRSxPQUFPUSxHQUFHO1FBQ1YsT0FBT0YsS0FBS3RCLFNBQVMsQ0FBQztJQUN4QixTQUFVO1FBQ1IsTUFBT08sSUFBSWMsTUFBTSxLQUFLLEVBQUc7WUFDdkIsSUFBSUksT0FBT2xCLElBQUltQixHQUFHO1lBQ2xCLElBQUlELEtBQUtKLE1BQU0sS0FBSyxHQUFHO2dCQUNyQk0sT0FBT0MsY0FBYyxDQUFDSCxJQUFJLENBQUMsRUFBRSxFQUFFQSxJQUFJLENBQUMsRUFBRSxFQUFFQSxJQUFJ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QUUsR0FBR21CO1lBQ2QsT0FBTztnQkFDTCxPQUFPQTtZQUNUO1FBQ0Y7UUFDQVYsTUFBTWYsR0FBRztJQUNYO0FBQ0Y7QUFFQSwrREFBK0Q7QUFDL0Qsa0NBQWtDO0FBQ2xDLFNBQVNILG9CQUFxQlIsUUFBUTtJQUNwQ0EsV0FDRSxPQUFPQSxhQUFhLGNBQ2hCQSxXQUNBLFNBQVVpQixDQUFDLEVBQUV1QixDQUFDO1FBQ2QsT0FBT0E7SUFDVDtJQUNKLE9BQU8sU0FBVVIsR0FBRyxFQUFFaEIsR0FBRztRQUN2QixJQUFJdkIsY0FBY2EsTUFBTSxHQUFHLEdBQUc7WUFDNUIsSUFBSyxJQUFJc0IsSUFBSSxHQUFHQSxJQUFJbkMsY0FBY2EsTUFBTSxFQUFFc0IsSUFBSztnQkFDN0MsSUFBSWxCLE9BQU9qQixhQUFhLENBQUNtQyxFQUFFO2dCQUMzQixJQUFJbEIsSUFBSSxDQUFDLEVBQUUsS0FBS3NCLE9BQU90QixJQUFJLENBQUMsRUFBRSxLQUFLTSxLQUFLO29CQUN0Q0EsTUFBTU4sSUFBSSxDQUFDLEVBQUU7b0JBQ2JqQixjQUFjZ0QsTUFBTSxDQUFDYixHQUFHO29CQUN4QjtnQkFDRjtZQUNGO1FBQ0Y7UUFDQSxPQUFPNUIsU0FBUzBDLElBQUksQ0FBQyxJQUFJLEVBQUVWLEtBQUtoQjtJQUNsQztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLWFwcC8uL25vZGVfbW9kdWxlcy9mYXN0LXNhZmUtc3RyaW5naWZ5L2luZGV4LmpzPzM3MmUiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdpZnlcbnN0cmluZ2lmeS5kZWZhdWx0ID0gc3RyaW5naWZ5XG5zdHJpbmdpZnkuc3RhYmxlID0gZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeVxuc3RyaW5naWZ5LnN0YWJsZVN0cmluZ2lmeSA9IGRldGVybWluaXN0aWNTdHJpbmdpZnlcblxudmFyIExJTUlUX1JFUExBQ0VfTk9ERSA9ICdbLi4uXSdcbnZhciBDSVJDVUxBUl9SRVBMQUNFX05PREUgPSAnW0NpcmN1bGFyXSdcblxudmFyIGFyciA9IFtdXG52YXIgcmVwbGFjZXJTdGFjayA9IFtdXG5cbmZ1bmN0aW9uIGRlZmF1bHRPcHRpb25zICgpIHtcbiAgcmV0dXJuIHtcbiAgICBkZXB0aExpbWl0OiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICBlZGdlc0xpbWl0OiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuICB9XG59XG5cbi8vIFJlZ3VsYXIgc3RyaW5naWZ5XG5mdW5jdGlvbiBzdHJpbmdpZnkgKG9iaiwgcmVwbGFjZXIsIHNwYWNlciwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zKClcbiAgfVxuXG4gIGRlY2lyYyhvYmosICcnLCAwLCBbXSwgdW5kZWZpbmVkLCAwLCBvcHRpb25zKVxuICB2YXIgcmVzXG4gIHRyeSB7XG4gICAgaWYgKHJlcGxhY2VyU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICByZXMgPSBKU09OLnN0cmluZ2lmeShvYmosIHJlcGxhY2VyLCBzcGFjZXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IEpTT04uc3RyaW5naWZ5KG9iaiwgcmVwbGFjZUdldHRlclZhbHVlcyhyZXBsYWNlciksIHNwYWNlcilcbiAgICB9XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoJ1t1bmFibGUgdG8gc2VyaWFsaXplLCBjaXJjdWxhciByZWZlcmVuY2UgaXMgdG9vIGNvbXBsZXggdG8gYW5hbHl6ZV0nKVxuICB9IGZpbmFsbHkge1xuICAgIHdoaWxlIChhcnIubGVuZ3RoICE9PSAwKSB7XG4gICAgICB2YXIgcGFydCA9IGFyci5wb3AoKVxuICAgICAgaWYgKHBhcnQubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYXJ0WzBdLCBwYXJ0WzFdLCBwYXJ0WzNdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydFswXVtwYXJ0WzFdXSA9IHBhcnRbMl1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBzZXRSZXBsYWNlIChyZXBsYWNlLCB2YWwsIGssIHBhcmVudCkge1xuICB2YXIgcHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwYXJlbnQsIGspXG4gIGlmIChwcm9wZXJ0eURlc2NyaXB0b3IuZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAocHJvcGVydHlEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBhcmVudCwgaywgeyB2YWx1ZTogcmVwbGFjZSB9KVxuICAgICAgYXJyLnB1c2goW3BhcmVudCwgaywgdmFsLCBwcm9wZXJ0eURlc2NyaXB0b3JdKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXBsYWNlclN0YWNrLnB1c2goW3ZhbCwgaywgcmVwbGFjZV0pXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhcmVudFtrXSA9IHJlcGxhY2VcbiAgICBhcnIucHVzaChbcGFyZW50LCBrLCB2YWxdKVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlY2lyYyAodmFsLCBrLCBlZGdlSW5kZXgsIHN0YWNrLCBwYXJlbnQsIGRlcHRoLCBvcHRpb25zKSB7XG4gIGRlcHRoICs9IDFcbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHN0YWNrW2ldID09PSB2YWwpIHtcbiAgICAgICAgc2V0UmVwbGFjZShDSVJDVUxBUl9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICB0eXBlb2Ygb3B0aW9ucy5kZXB0aExpbWl0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgZGVwdGggPiBvcHRpb25zLmRlcHRoTGltaXRcbiAgICApIHtcbiAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBvcHRpb25zLmVkZ2VzTGltaXQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICBlZGdlSW5kZXggKyAxID4gb3B0aW9ucy5lZGdlc0xpbWl0XG4gICAgKSB7XG4gICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBzdGFjay5wdXNoKHZhbClcbiAgICAvLyBPcHRpbWl6ZSBmb3IgQXJyYXlzLiBCaWcgYXJyYXlzIGNvdWxkIGtpbGwgdGhlIHBlcmZvcm1hbmNlIG90aGVyd2lzZSFcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRlY2lyYyh2YWxbaV0sIGksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbClcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldXG4gICAgICAgIGRlY2lyYyh2YWxba2V5XSwga2V5LCBpLCBzdGFjaywgdmFsLCBkZXB0aCwgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhY2sucG9wKClcbiAgfVxufVxuXG4vLyBTdGFibGUtc3RyaW5naWZ5XG5mdW5jdGlvbiBjb21wYXJlRnVuY3Rpb24gKGEsIGIpIHtcbiAgaWYgKGEgPCBiKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKGEgPiBiKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuICByZXR1cm4gMFxufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmlzdGljU3RyaW5naWZ5IChvYmosIHJlcGxhY2VyLCBzcGFjZXIsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAndW5kZWZpbmVkJykge1xuICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucygpXG4gIH1cblxuICB2YXIgdG1wID0gZGV0ZXJtaW5pc3RpY0RlY2lyYyhvYmosICcnLCAwLCBbXSwgdW5kZWZpbmVkLCAwLCBvcHRpb25zKSB8fCBvYmpcbiAgdmFyIHJlc1xuICB0cnkge1xuICAgIGlmIChyZXBsYWNlclN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmVzID0gSlNPTi5zdHJpbmdpZnkodG1wLCByZXBsYWNlciwgc3BhY2VyKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSBKU09OLnN0cmluZ2lmeSh0bXAsIHJlcGxhY2VHZXR0ZXJWYWx1ZXMocmVwbGFjZXIpLCBzcGFjZXIpXG4gICAgfVxuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KCdbdW5hYmxlIHRvIHNlcmlhbGl6ZSwgY2lyY3VsYXIgcmVmZXJlbmNlIGlzIHRvbyBjb21wbGV4IHRvIGFuYWx5emVdJylcbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBFbnN1cmUgdGhhdCB3ZSByZXN0b3JlIHRoZSBvYmplY3QgYXMgaXQgd2FzLlxuICAgIHdoaWxlIChhcnIubGVuZ3RoICE9PSAwKSB7XG4gICAgICB2YXIgcGFydCA9IGFyci5wb3AoKVxuICAgICAgaWYgKHBhcnQubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYXJ0WzBdLCBwYXJ0WzFdLCBwYXJ0WzNdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydFswXVtwYXJ0WzFdXSA9IHBhcnRbMl1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmlzdGljRGVjaXJjICh2YWwsIGssIGVkZ2VJbmRleCwgc3RhY2ssIHBhcmVudCwgZGVwdGgsIG9wdGlvbnMpIHtcbiAgZGVwdGggKz0gMVxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoc3RhY2tbaV0gPT09IHZhbCkge1xuICAgICAgICBzZXRSZXBsYWNlKENJUkNVTEFSX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiB2YWwudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBvcHRpb25zLmRlcHRoTGltaXQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICBkZXB0aCA+IG9wdGlvbnMuZGVwdGhMaW1pdFxuICAgICkge1xuICAgICAgc2V0UmVwbGFjZShMSU1JVF9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIG9wdGlvbnMuZWRnZXNMaW1pdCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIGVkZ2VJbmRleCArIDEgPiBvcHRpb25zLmVkZ2VzTGltaXRcbiAgICApIHtcbiAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHN0YWNrLnB1c2godmFsKVxuICAgIC8vIE9wdGltaXplIGZvciBBcnJheXMuIEJpZyBhcnJheXMgY291bGQga2lsbCB0aGUgcGVyZm9ybWFuY2Ugb3RoZXJ3aXNlIVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGV0ZXJtaW5pc3RpY0RlY2lyYyh2YWxbaV0sIGksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDcmVhdGUgYSB0ZW1wb3Jhcnkgb2JqZWN0IGluIHRoZSByZXF1aXJlZCB3YXlcbiAgICAgIHZhciB0bXAgPSB7fVxuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpLnNvcnQoY29tcGFyZUZ1bmN0aW9uKVxuICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV1cbiAgICAgICAgZGV0ZXJtaW5pc3RpY0RlY2lyYyh2YWxba2V5XSwga2V5LCBpLCBzdGFjaywgdmFsLCBkZXB0aCwgb3B0aW9ucylcbiAgICAgICAgdG1wW2tleV0gPSB2YWxba2V5XVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwYXJlbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGFyci5wdXNoKFtwYXJlbnQsIGssIHZhbF0pXG4gICAgICAgIHBhcmVudFtrXSA9IHRtcFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRtcFxuICAgICAgfVxuICAgIH1cbiAgICBzdGFjay5wb3AoKVxuICB9XG59XG5cbi8vIHdyYXBzIHJlcGxhY2VyIGZ1bmN0aW9uIHRvIGhhbmRsZSB2YWx1ZXMgd2UgY291bGRuJ3QgcmVwbGFjZVxuLy8gYW5kIG1hcmsgdGhlbSBhcyByZXBsYWNlZCB2YWx1ZVxuZnVuY3Rpb24gcmVwbGFjZUdldHRlclZhbHVlcyAocmVwbGFjZXIpIHtcbiAgcmVwbGFjZXIgPVxuICAgIHR5cGVvZiByZXBsYWNlciAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgID8gcmVwbGFjZXJcbiAgICAgIDogZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgICAgcmV0dXJuIHZcbiAgICAgIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbCkge1xuICAgIGlmIChyZXBsYWNlclN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVwbGFjZXJTdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IHJlcGxhY2VyU3RhY2tbaV1cbiAgICAgICAgaWYgKHBhcnRbMV0gPT09IGtleSAmJiBwYXJ0WzBdID09PSB2YWwpIHtcbiAgICAgICAgICB2YWwgPSBwYXJ0WzJdXG4gICAgICAgICAgcmVwbGFjZXJTdGFjay5zcGxpY2UoaSwgMSlcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsKVxuICB9XG59XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInN0cmluZ2lmeSIsImRlZmF1bHQiLCJzdGFibGUiLCJkZXRlcm1pbmlzdGljU3RyaW5naWZ5Iiwic3RhYmxlU3RyaW5naWZ5IiwiTElNSVRfUkVQTEFDRV9OT0RFIiwiQ0lSQ1VMQVJfUkVQTEFDRV9OT0RFIiwiYXJyIiwicmVwbGFjZXJTdGFjayIsImRlZmF1bHRPcHRpb25zIiwiZGVwdGhMaW1pdCIsIk51bWJlciIsIk1BWF9TQUZFX0lOVEVHRVIiLCJlZGdlc0xpbWl0Iiwib2JqIiwicmVwbGFjZXIiLCJzcGFjZXIiLCJvcHRpb25zIiwiZGVjaXJjIiwidW5kZWZpbmVkIiwicmVzIiwibGVuZ3RoIiwiSlNPTiIsInJlcGxhY2VHZXR0ZXJWYWx1ZXMiLCJfIiwicGFydCIsInBvcCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5Iiwic2V0UmVwbGFjZSIsInJlcGxhY2UiLCJ2YWwiLCJrIiwicGFyZW50IiwicHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0IiwiY29uZmlndXJhYmxlIiwidmFsdWUiLCJwdXNoIiwiZWRnZUluZGV4Iiwic3RhY2siLCJkZXB0aCIsImkiLCJBcnJheSIsImlzQXJyYXkiLCJrZXlzIiwia2V5IiwiY29tcGFyZUZ1bmN0aW9uIiwiYSIsImIiLCJ0bXAiLCJkZXRlcm1pbmlzdGljRGVjaXJjIiwidG9KU09OIiwic29ydCIsInYiLCJzcGxpY2UiLCJjYWxsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fast-safe-stringify/index.js\n");

/***/ })

};
;